# Kotlin List Comprehensions

One of the nicest features of the Python programming language is the conciseness with which you can write your programs. One of those features is the Python list comprehension.
The purpose of this feature is for creating lists in a single line. Think of a loop of which the result of each iteration is appended to a list which is then returned.
This is a really simplistic list comprehension in Python, essentially being the same as just converting the range object to a list

```python
[i for i in range(5)]
```

List comprehensions are for sure my favorite feature of Python and mostly were the thing that I missed instantly when I first saw it.

But did you know you can actually have list comprehensions in Kotlin, as well as most modern programming languages? The secret is the `map` function found not only in Kotlin, but almost any high-level language, that, combined with range expressions, can achieve the same level of conciseness as a list comprehension.

Let's look at the example from above. We can use the nice range expressions from Kotlin, and achieve exactly the same thing!

```kotlin
(0..5).map { it }
```

This of course, just like in Python doesn't just work with range expressions, but, in fact, with every Iterable.

Of major advantage this has over Python we have a true lambda here that allows us to create local variables, making more complex list comprehensions possible.
Not only that, Kotlin list comprehensions are also usually very efficient because the map function is implemented as an inline function.
If we look at the generated Java code, we can see that the lambda is completely eliminated after compilation.

```kotlin
fun main() {
    val list = (0..5).map { it }

    println(list)
}
```

```java
Iterable $this$map$iv = (Iterable)(new IntRange(var1, 5));
Collection destination$iv$iv = (Collection)(new ArrayList(CollectionsKt.collectionSizeOrDefault($this$map$iv, 10)));
Iterator var6 = $this$map$iv.iterator();

while(var6.hasNext()) {
   int item$iv$iv = ((IntIterator)var6).nextInt();
   Integer var11 = item$iv$iv;
   destination$iv$iv.add(var11);
}

List list = (List)destination$iv$iv;
System.out.println(list);
```

One notable thing here is that the Kotlin compiler doesn't realize that you could replace the ranges with a simple loop, so we actually end up with a lot more object allocations then necessary. In this case there is actually a just as neat but more efficient way to write this. The Kotlin Array constructor takes a size and optionally also an instantiate variable, meaning you can write this instead which yields very clean bytecode.

```kotlin
fun main() {
    val list = IntArray(5) { it }

    println(list)
}
```

```java
byte var1 = 5;
int[] var2 = new int[var1];

for(int var3 = 0; var3 < var1; var2[var3] = var3++) { }

System.out.println(var2);
```

I couldn't have written it better myself, and we now just end up with a single object allocation. This is really only interesting in high performance environments, but I still included it as a reminder that looking at the generated bytecode can often be worth it as the benchmarks will show in a moment.

Creating a 1000000 element `IntArray` 100 times took ~100ms to execute, while the same thing with a range took 3.6 seconds, which is an absolute insane difference.
This problem of course mainly lies in the nature of the range function, for most of the usual applications Kotlin is able to convert it to a normal loop, however in more complex use cases it might fall back to a Python-like range object allocation. Just out of curiosity I also looked into

```kotlin
fun main() {
    val list = (0..5).toList()

    println(list)
}
```

it's about 500ms faster than the map version, but not significant enough.

This should serve as a reminder that while a lot of the Kotlin goodies are free and yield near native performance, some also come at a significant cost.

Don't be discouraged by this however to use Kotlin list comprehensions. Even in edge cases they will often end up performing twice as fast as in Python, in most cases they are not even close.



Fun fact: while performing those benchmarks, I became curious how C would perform. The answer is: equally or worse. Why? Allocations in C seem to be less efficient then they are in Java.

```c
LARGE_INTEGER start, end, elapsed_ms;
LARGE_INTEGER frequency;
QueryPerformanceFrequency(&frequency);
QueryPerformanceCounter(&start);

for (int i = 0; i < 1000; i++) {
    int list = malloc(1000000 * sizeof(int));
    for (int j = 0; j < 1000000; j++) {
        list[j] = j;
    }
    free()
    // freeing memory doesn't really affect performance
}

QueryPerformanceCounter(&end);
elapsed_ms.QuadPart = end.QuadPart - start;
elapsed_ms.QuadPart *= 1000LL; // conver
elapsed_ms.QuadPart /= frequency.QuadPart;

printf("%lld\n", elapsed_ms.QuadPart);
```

```kotlin
val native = measureTime {
	for (i in 0..1_000)
		IntArray(1_000_00) { it }
}
```

Crazy, isn't it? How can native be slower than a program running on the JVM?
Easy, the JVM applied a sneaky optimization here. It is not, as one might think, eliminating the useless code, it is a little more subtle.

```c
for (register int i = 0; i < 1000; i++) {
    int list = malloc(1000000 * sizeof(int));
    for (register int j = 0; j < 1000000; j++) {
        list[j] = j;
    }
    free()
}
```

Notice the difference? The iteration variables are now bound to the hardware registers, which yields a nice 100% increase in performance. This is still significantly slower than the JVM counterpart because allocations still seem slower in C than in Java, but it explains a lot.